# 🎯 テストガイドライン - 見落とし防止チェックリスト

## 📊 テスト観点の全体マップ

### **機能観点（How to Test）**

#### **入力・動作の検証方法**
- **ポジティブテスト**: 正常な入力・操作での期待動作
- **ネガティブテスト**: 異常な入力・エラー時の動作
- **境界値テスト**: 最大値・最小値・限界値での動作
- **等価分割テスト**: 同じ結果になる入力グループの代表値

#### **統合レベル（Scope of Test）**  
- **単体テスト**: 1つの関数・コンポーネント
- **統合テスト**: 複数コンポーネント間の連携
- **システムテスト**: 全体システムとしての動作
- **E2Eテスト**: ユーザー視点での一連フロー

#### **時間観点（When to Test）**
- **静的テスト**: 初期状態・固定状態
- **動的テスト**: 操作後・状態変化後
- **状態遷移テスト**: A状態→B状態→C状態の流れ
- **並行処理テスト**: 同時実行・競合状態

#### **データ観点（Data Persistence）**
- **データ永続化テスト**: セーブ・ロード・DB操作
- **データ整合性テスト**: データの矛盾・破損検証
- **データマイグレーションテスト**: バージョンアップ時のデータ変換

---

## 🔍 新機能実装時の必須チェックリスト

### **CRUD操作がある場合**
- ✅ Create（作成）- 正常な作成動作
- ✅ Read（読み込み）- 作成したデータの表示
- ✅ Update（更新）- データ変更動作
- ✅ Delete（削除）- データ削除動作
- ❗ **各操作後の状態確認** - 操作が他の機能に影響しないか
- ❗ **操作失敗時のrollback** - 失敗時に整合性が保たれるか

### **状態を持つ機能**
- ✅ 初期状態 - 起動時・リセット時の状態
- ❗ **状態変更後の動作** - 状態Aから状態Bに変わった後の挙動
- ❗ **複数回状態変更** - A→B→C→Aのような循環遷移
- ❗ **不正な状態での動作** - 予期しない状態での動作

### **UI操作がある場合**
- ✅ クリック・タップ - 基本操作
- ❗ **連続クリック** - ダブルクリック・連打耐性
- ❗ **無効状態での操作** - disabled時のクリック
- ❗ **画面リロード後** - ページ更新後の状態保持

### **データ保存がある場合**
- ✅ 保存成功 - 正常な保存動作
- ❗ **保存→ロード→使用** - 保存したデータでの動作継続
- ❗ **保存失敗時** - ストレージ不足・権限エラー等
- ❗ **データ破損時** - 不完全・壊れたデータの読み込み

---

## ⚠️ よくある見落としパターン

### **状態遷移系の見落とし**
- 初期状態のテストのみ（変更後未確認）
- A→B遷移のみ（B→A復帰未確認）  
- 正常遷移のみ（異常遷移未確認）

### **エラーハンドリング系の見落とし**
- 成功ケースのみテスト
- ネットワークエラー未考慮
- 不正データ処理未確認
- 例外発生時のUI状態未確認

### **統合系の見落とし**
- 単体では動くが組み合わせで失敗
- 異なるブラウザ・デバイス未確認
- 同時実行・競合状態未確認
- コンポーネント間のデータ受け渡し未確認

### **データ系の見落とし**
- 保存までテスト済みだが読込み後未確認
- 正常データのみ（破損データ未考慮）
- バージョン違いデータ未考慮
- データサイズ上限未確認

---

## 🎯 機能別専用チェックポイント

### **認証・セッション機能**
- ログイン成功/失敗
- **セッション期限切れ後の操作**
- **ログイン→操作→ログアウト→再ログイン**
- **複数タブでの同時ログイン**

### **データ入力機能**
- 正常入力/異常入力
- **文字数制限境界値**
- **特殊文字・絵文字・外国語**
- **コピー&ペースト動作**

### **ファイル操作機能**
- アップロード成功/失敗
- **ファイルサイズ制限**
- **拡張子制限・MIME type**
- **破損ファイル・空ファイル**

### **API連携機能**
- 通信成功/失敗
- **タイムアウト・レスポンス遅延**
- **不正レスポンス・空レスポンス**
- **認証エラー・権限エラー**

### **リアルタイム機能（WebSocket等）**
- 接続成功/失敗
- **接続切断・再接続**
- **メッセージ送受信エラー**
- **大量データ受信時の性能**

---

## 💡 実装時の5つの自問チェック

### 1. **「この機能、状態を持ってる？」**
→ 持ってたら**状態遷移テスト必須**
- 初期状態だけでなく変更後の動作確認
- 状態の組み合わせパターン検証

### 2. **「エラーが起きたらどうなる？」**
→ **エラーハンドリングテスト必須**
- 想定できるエラー全パターン
- エラー時のユーザー体験確認

### 3. **「他の機能と連携してる？」**
→ **統合テスト必須**  
- 単独動作と連携動作の両方確認
- データ受け渡しの整合性検証

### 4. **「データを保存・読込みしてる？」**
→ **データ永続化テスト必須**
- 保存→読込み→使用の一連フロー
- データ形式変更時の互換性

### 5. **「ユーザーが連続で操作したら？」**
→ **連続操作・競合テスト必須**
- 高速連続操作の耐性
- 同時操作時の競合処理

---

## 🔬 現実的テストケース設計手法

### **問題: 「GitHub Actions は通るが実際は動かない」への対策**

#### **1. ユーザー報告の詳細分析**
```
ユーザー報告 → 技術的問題特定 → 既存テストの限界分析
```

**具体例（Epic Battle RPG v0.41）:**
- **報告**: 「街でセーブしても戦闘画面から開始される」
- **技術問題**: 画面状態がセーブデータに含まれていない
- **テスト限界**: セーブ・ロード機能は確認済みだが画面状態は未確認

#### **2. テストケース設計の論理構築**
```
IF (実際のユーザー操作)
THEN (期待される動作)
BUT (実際に発生している問題)
```

**設計思考プロセス:**
1. **問題の再現**: ユーザーの操作を正確に模倣
2. **期待値の明確化**: 修正後に通るべき条件を定義
3. **検出力の確認**: 修正前に確実に失敗するかを検証

#### **3. 現実的シナリオの構築**

**従来のテスト（機能単体）:**
```javascript
test('Save/Load works', async ({ page }) => {
    await page.click('#save-btn');
    await page.click('#load-btn');
    // → 機能は動作するが状態は確認していない
});
```

**改善後のテスト（現実的フロー）:**
```javascript
test('Town Save-Load Screen State Preservation', async ({ page }) => {
    // Step 1: 街画面に移動
    await page.click('#town-btn');
    
    // Step 2: 街画面でセーブ  
    await page.click('#town-save-btn');
    
    // Step 3: ロード後も街画面から開始
    await page.click('#load-btn');
    await expect(townScreen).not.toHaveClass(/hidden/);
});
```

#### **4. 複合シナリオテストの価値**

**複雑な状態遷移での統合テスト:**
```
戦闘 → 街 → 武器変更 → 戦闘 → セーブ → ロード → 攻撃
```

**なぜ複合テストが重要か:**
- ✅ **状態の複雑性**: 単体では動くが組み合わせで失敗
- ✅ **実際の使用パターン**: ユーザーの本当の操作フロー
- ✅ **隠れたバグ**: 状態蓄積による問題の検出

---

## 📝 新機能追加時のテストケース作成マニュアル

### **Step 1: 機能の性質分析**

#### **📊 機能の分類チェック**
- ☑️ **UI操作**: ボタン・入力・画面遷移がある
- ☑️ **状態管理**: データ・設定・進行状況を保持する
- ☑️ **データ永続化**: セーブ・ロード・DB操作がある
- ☑️ **他機能連携**: 既存機能との相互作用がある
- ☑️ **リアルタイム性**: 即座の反応・更新が必要

#### **📈 複雑度レベルの判定**
- **Level 1 (基本)**: 単純な入力・出力のみ
- **Level 2 (中級)**: 状態変更・画面遷移あり
- **Level 3 (高級)**: 複数機能連携・データ永続化
- **Level 4 (最高)**: リアルタイム・競合処理・外部API

### **Step 2: テストケース追加判定**

#### **🟢 必ずテストケースを追加する場合**
- **Level 3以上の機能**: 統合テスト必須
- **既存機能の修正**: 回帰テスト必須
- **ユーザー報告があった問題**: 再現テスト必須
- **状態 + データ保存 + 他機能連携**: 包括テスト必須

#### **🟡 テストケース追加を検討する場合**
- **Level 2の機能**: 重要度に応じて判断
- **UI変更のみ**: 影響範囲が大きい場合は追加
- **パフォーマンス改善**: 測定可能な場合は追加

#### **🔴 テストケース追加が不要な場合**
- **Level 1の機能**: 既存テストで十分カバー
- **CSS調整のみ**: 機能に影響しない見た目の変更
- **ログ追加のみ**: 動作に影響しない情報追加

### **Step 3: テストケース設計テンプレート**

#### **基本テンプレート**
```javascript
test('🎯 [機能名] - [シナリオ]', async ({ page }) => {
    // エラー監視設定
    const consoleErrors = [];
    const pageErrors = [];
    
    page.on('console', msg => {
        if (msg.type() === 'error') consoleErrors.push(msg.text());
    });
    page.on('pageerror', error => {
        pageErrors.push(error.message);
    });
    
    // Step 1: 前提条件の設定
    // Step 2: 実際の操作
    // Step 3: 結果の検証
    // Step 4: エラーチェック
    
    expect(criticalErrors.length).toBe(0);
});
```

#### **状態遷移テンプレート**
```javascript
test('🔄 [機能名] State Transition', async ({ page }) => {
    // 初期状態 → 変更後状態 → 復帰確認
    // 各状態での他機能動作確認
});
```

#### **データ永続化テンプレート**
```javascript
test('💾 [機能名] Data Persistence', async ({ page }) => {
    // データ作成 → セーブ → ロード → データ使用
    // 破損データ・旧バージョンデータの処理確認
});
```

### **Step 4: テスト実装の品質チェック**

#### **✅ 実装後の自己チェックリスト**
- [ ] **意図が明確**: テストの目的がコメントで説明されている
- [ ] **再現性**: 何度実行しても同じ結果になる
- [ ] **独立性**: 他のテストの実行順序に影響されない
- [ ] **現実性**: 実際のユーザー操作を模倣している
- [ ] **包括性**: 正常系・異常系の両方をカバー
- [ ] **検出力**: 実際の問題を確実に検出できる

#### **🔍 テストの有効性検証**
1. **わざとバグを作る**: 一時的にコードを壊してテストが失敗するか確認
2. **境界値で確認**: 最大・最小・限界値でのテスト動作
3. **エラー条件で確認**: ネットワーク切断・権限不足等での動作

### **Step 5: 継続的改善**

#### **📊 テストの効果測定**
- **検出率**: 実際のバグをどれくらい見つけられるか
- **偽陽性率**: 問題ないのに失敗する頻度
- **実行時間**: CI/CDパイプラインへの影響
- **保守コスト**: テストの修正・更新の頻度

#### **🔄 定期見直しプロセス**
- **月次**: テスト失敗の原因分析・傾向把握
- **四半期**: テストケースの有効性レビュー
- **リリース前**: 新機能テストの網羅性確認
- **バグ発生時**: 見落としたテスト観点の特定・追加

---

## 🏆 テスト品質向上のベストプラクティス

### **テスト設計時**
- Happy Pathだけでなく、Sad Pathも必ず含める
- 実際のユーザー操作パターンを想定する
- エラー時のユーザビリティも検証対象にする

### **テスト実装時**
- 各テストの意図を明確にコメントで記述
- テスト失敗時の原因特定しやすい構造にする
- テスト環境の状態をテスト間で適切にリセット

### **テスト運用時**
- CI/CDパイプラインに組み込み自動実行
- テスト失敗時は即座に修正（放置しない）
- 定期的なテストケース見直しとメンテナンス

---

## 📋 チーム共有時の活用方法

1. **コードレビュー時のチェックリスト**として使用
2. **新機能実装前の設計レビュー**で参照
3. **バグ発生時の原因分析**で見落とした観点を特定
4. **テストケース作成時の網羅性確認**に活用

---

*このガイドラインは実際の開発現場での失敗経験を基に作成されています。*
*継続的な改善により、より実践的な内容に更新していきます。*